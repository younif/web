基本方法：
1. （资源类）大多数类因为其代表着计算机中的资源,所以设计成不可拷贝，将拷贝构造函数私有。
2. （智能指针）内部设计时要避免原始指针的使用。
3. （pimpl）尽量使用前向声明减少组件之间的依赖，提高抽象程度，降低二次编译时间。
4.  (模块化) 采用function/bind代替虚函数作为接口

TcpServer
主reactor+几个子reactor的结构。
主reactor负责接收新链接，负载均衡分配到子reactor中，避免群惊现象。
- 对外接口（常用的TCP与套接字设置）
    - ip:port设置
    - TCP Keepalive设置
    - backlog设置
    - TCP 发送、接收缓冲大小
    - 超时响应限制
    - 最大连接数
    -

EventLoop
reactor模式实现，收集、分发、执行事件，由IO线程创建。
每个线程只能创建一个EventLoop实例，当已经创建时，则结束进程。

Channel
事件订阅的管理接口类、与EventLoop配合使用。对事件资源不拥有
初始化时向EventLoop类注册监听。提供对事件的订阅控制。

Poll
对IO多路复用进行抽象。

Acceptor
负责打开监听描述符，并在有新链接到来时执行用户的回调函数。

TcpConnection
对已建立的TCP链接资源的包装。

ByteBuf
TCP链接在内核中的缓存栈层次：ring_buf-sk_buf-TCP_receive/send_buf。

作为非阻塞网络编程库，需要再向上提供灵活长度的缓冲层，来解决不能一次性发送或者接收足够长数据的基本需求。
更为上层的需求是，将数据读取后自动反射为结构化的数据。这里尝试与protobuf、grpc结合来实现相关的功能。

http parser
在数据来临时，需要对字节流进行解析并生成结构化的HTTP数据，并在解析的过程中出错则及时停止并返回错误。


线程安全
1. Mutex.h ，使用clang的静态检查工具，确定被保护的变量在使用时是否上锁
2. 明确那些线程安全的成员函数可以被其他线程调用，非线程安全函数检查运行时是否在本线程执行
3. 当非线程安全的成员函数被调用，则结束进程（FastFail），防止隐晦问题不能及时发现。

HTTP/1.0协议的优化空间
HTTP/1.0主要延时
    1. DNS解析时延（如果没有缓存）-->由URI确定IP与端口号
    2. TCP三次握手连接建立时延 -->使用TCP协议的必须开销
    3. 服务器接收请求并响应报文时延
TCP对HTTP/1.0的影响与应对策略
    1. TCP建立的时延--keepalive持久连接，减少建立次数
    2. 慢启动拥塞控制--keepalive持久连接，避开建立时的慢启动
    3. Nagle算法 --设置TCP_NODELAY（HTTP请求应答模式不搭配 ）
    4. TIME_WAIT积累端口耗尽（服务端主动关闭） -- 性能测试用，设置reuseaddr
    5. TCP队头堵塞 --弱网环境下（丢包率高），堵塞会严重


