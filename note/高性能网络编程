非阻塞编程知识总结

传输文件与零拷贝：
    零拷贝优化是指数据在硬盘、用户态内存、内核态内存、网卡之间的数据拷贝优化，主要是基于内存映射来减少拷贝。
    HTTP的get方法就是将网页文件传输给客户端。但是网页文件一般很短，建立的是TCP短链接。
    大文件传输时，如果一次性将文件读入内存，则对内存消耗过大。我们可以为链接设置上下文，记录传输的位置，并在可写时一段一段读取然后传输。
    但是这些方式都需要从硬盘读入用户态内存，然后载总用户太内存拷贝至内核，最后通过驱动发送到网卡中。
    一种方式是可以使用mmap调用直接将文件映射到内存中，这样就可以减少一步拷贝。
    也可以使用sendfile调用


TCP分包与序列化：
    TCP是将链接通信抽象为双向的无限字节流，所以数据之间没有边界，而现实情况书我们需要从中截取出带有结构的数据。所以这就是TCP的分包需求来源。
    序列化是因为带有结构的数据在不同的系统平台上的表示是不同的。比如大小端在不同的操作系统和不同指令集的架构下会有不同，不同的编程语言对数据的格式表达会有不同。
    序列化是将带有结构的数据“拉成“一长串没有结构的数据字符流，反序列化相反。
    最简单的序列化方式是，只考虑数据的大小，即在数据前标记数据的长度。通过这样的方式我们只要在另一端先读取长度信息，在读取固定长度的信息即可得到该长度的字符串。

并发与内存一致性模型：

多线程避免伪共享--CacheLine大小内的读写引起的缓存失效

select\poll\epoll\io_uring的发展逻辑:
    select与poll是每次将需要查询的文件描述符通过系统调用传入，然后内核返回结果。
    可以同时监听多个文件描述符的事件，所以这些方式也就被称为IO多路复用。

    但是这两种都有一个缺点就是，如果同时监听很多描述符则每次都需要从用户态拷贝大量的数据，导致性能不佳.
    epoll则在内核中保留了需要监听的描述符的集合，这样每次只需要修改必要的部分即可。
    但是这也会导致调试变得复杂，因为epoll在内核中有状态，而前两个则是在内核中无状态的。

    io_uring的提出是则为了解决另一些问题，比如频繁的系统调用的开销。通过内核与用户态共享内存的方式，给出两个队列。
    一个是IO操作提交队列，另一个是完成队列。提交队列可以直接将数据写入内核中减少拷贝。通过批量提交请求到队列，可以减少系统调用产生的开销。

    避免系统调用开销的另一种方式就是使用用户态协议栈。通常网卡设备由内核通过驱动程序与内核网络协议栈使用。
    内核通过文件映射到网卡内存的方式，实现对文件的读写就是对网卡内存的读写，这样应用程序就可以直接与网卡进行交互，处理网卡上的收发队列上的数据。
    当然还有其他的实现机制，比如VFIO与IOMMU实现的方式。



